# Content
- [Request Response](#request-response)
- [Synchronous vs Asynchronous workloads](#synchronous-vs-asynchronous-workloads)
- [Push](#push)
- [Short Polling](#short-polling)
- [Long Polling](#long-polling)


# Request Response
1. **Client** sends a **Request**.
  - In **TCP**, the data that the **Client** send is a continuous stream of data. Data may be serialized.
2. **Server** parses the **Request**
  - **Server** needs to parse the data to look for the start and end of a **Request**.
3. **Server** processes the **Request**
  - De-serialization may be needed.
4. **Server** sends a **Response**
5. **Client** parses the Response and consume.

![image](https://github.com/boushphong/BE-Fundamentals/assets/59940078/7c030a09-6dfd-437b-9cbd-0ea32a0e8178)

## Where it is used?
- Web, HTTP, DNS, SSH
- RPC (Remote Procedure Call)
- SQL and Database Protocols
- APIs (REST/SOAP/GraphQL)

## Anatomy of a Request / Response
- A request structure is defined by both client and server. And they both have to agree on it based on the protocol being used.
- Request has a boundary and it is defined by a protocol and message format.


A GET HTTP Request structure.
```
GET HTTP/1.1
Headers
<CRLF>
BODY
```

For large requests, there are two options to send data.
- Send the entire large request (Simple)
- Send chunked requests (Efficient and resumable)

## Doesn't work everywhere
- Notification service
- Chatting application
- Very long-running request

# Synchronous vs Asynchronous workloads
## Synchronous I/O
- Caller sends a request and blocks.
- Caller cannot exeucute any code meanwhile.
- Receiver responds, Callers unblocks.
- Caller and Receiver are in "Sync".

### Example of an OS synchronous I/O
- Program asks OS to read form disk.
- Program main thread is taken off of the CPU.
- Read completes, program can resume execution.

## Asynchronous I/O
- Caller sends a request.
- Caller can work until it gets a response.
- Call either:
  - Checks if the response is ready (epoll).
  - Receiver calls back when it's done (io_uring).
- Caller and Receiver are not necessary in "Sync"

### Example of an OS asynchronous call (NodeJS)
- Program spins up a secondary thread.
- Secondary thread reads from disk, OS blocks it.
- Main program still running and executing code.
- Thread finishing reading and calls back main thread.

### Asynchronous workload is everywhere
- Asynchronous programming (promises/futures)
- Asynchronous backend processing.
- Asynchronous commit.
- Asynchronous IO in Linux (epoll, io_uring)
- Asynchronous replication.
- Asynchronous OS fsync (fs cache)

# Push
## Request/Response isn't always ideal
- Client wants real time notification from backend
  - A user just logged in
  - A message is just received
- Push model is good for above use cases.

## What is push?
- Client connects to a server
- Server sends data to the client
- Client doesn't have to request anything
- Protocol must be bidirectional
- Used by RabbitMQ

## Push pros and cons
- Pros:
  - Real time
- Cons:
  - Clients must be online to receive the push from the server.
  - Client might not be able to handle the load.
  - Requires a bidirectional protocol (WebSockets, HTTP/2 ...)
  - Polling is preferred for light clients.

# Short Polling
## What is Short Polling?
- Clients sends a request.
- Server responds immediately with a handle
- Server continues to process the request
- Client uses that handle to check for status (periodically, Client will continuously ask the server if there's anything new, such as new messages)
- Multiple "short" request response as polls

## Short Polling pros and cons
- Pros:
  - Simple
  - Good for long running requests
  - Client can disconnect (only with custom resuming techniques)
- Cons:
  - Too chatty (will congest the network)
  - Wasted backend resources.

# Long Polling
Request is taking long, I'll check with you later but talk to me only when it's ready.
## What is Long Polling?
- Clients sends a request.
- Server responds immediately with a handle
- Server continues to process the request
- Client uses that handle to check for status
- Server does not reply until it has the response
- Client polls the data at their leisure, timeout can be implemented (Kafka)
  - In Kafka, Consumers track the next offset they need to read from. This is often done in memory while the consumer is running. Consumers decide when to commit an offset and how frequently to do so.
  - When a consumer commits an offset, Kafka stores this information in a special internal topic named `__consumer_offsets`. The Kafka server is responsible for keeping track of these committed offsets. This allows consumers to pick up where they left off in the event of a restart or failure.

## Long Polling pros and cons
- Pros
  - Less chatty and backend friendly
  - Client can still disconnect
- Cons
  - Not real time
