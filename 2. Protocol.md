# Content
- [Protocol](#protocol)
- [OSI Model](#osi-model)
- [Internet Protocol](#internet-protocol)
- [ICMP](#icmp)
- [UDP](#udp)

# Protocol
## What is a protocol?
- A system that allows two parties to communicate
- A protocol is designed with a set of properties
- Depending on the purpose of the protocol
- TCP, UDP, HTTP, gRPC, FTP

## Protocol Properties
- **Data Format**
  - Text based (JSON, XML, plain text ...)
  - Binary (protobuf, HTTP2, HTTP3 ...)
- **Transfer mode**
  - Message based (UDP, HTTP)
  - Stream (TCP, WebRTC)
- **Addressing system**
  - DNS name, IP, MAC
- **Directionality**
  - Bidirectional (TCP)
  - Unidirectional (HTTP)
  - Full/Half Duplex
- **State**
  - Stateful (TCP, gRPC, Apache Thrift)
  - Stateless (HTTP, UDP)
- **Routing**
  - Proxies, Gateways

# OSI Model
## Why do we need a communication model?
- **Agnostic Applications**
  - Without a standard model, your application must have knowledge of the underlying network medium 
  - Imagine if you have to author different version of your apps so that it works on Wi-Fi vs ethernet vs LTE vs fiber 
- **Network Equipment Management**
  - Without a standard model, upgrading network equipments becomes difficult
- **Decoupled Innovation**
  - Innovations can be done in each layer separately without affecting the rest of the models 

## What is the OSI Model?
**7 Layers each describe a specific networking component** 
- Layer 7 - Application - HTTP/FTP/gRPC 
- Layer 6 - Presentation - Encoding, Serialization 
- Layer 5 - Session - Connection establishment, TLS 
- Layer 4 - Transport - UDP/TCP 
- Layer 3 - Network - IP 
- Layer 2 - Data link - Frames, Mac address Ethernet 
- Layer 1 - Physical - Electric signals, fiber or radio waves

**Example of sending a POST request to an HTTPS webpage**
- Layer 7 - Application 
  - POST request with JSON data to HTTPS server 
- Layer 6 - Presentation
  - Serialize JSON to flat byte strings
- Layer 5 - Session
  - Request to establish TCP connection/TLS 
- Layer 4 - Transport 
  - Sends SYN request target port 443
- Layer 3 - Network 
  - SYN is placed an IP packet(s) and adds the source/dest IPs
- Layer 2 - Data link
  - Each packet goes into a single frame and adds the source/dest MAC addresses 
- Layer 1 - Physical 
  - Each frame becomes string of bits which convened into either a radio signal (Wi-Fi), electric signal (ethernet), or light (fiber)

**Receiver computer receives the POST request the other way around**
- Layer 1 - Physical
  - Radio, electric or light is received and converted into digital bits
- Layer 2 - Data link
  - The bits from Layer 1 is assembled into frames
- Layer 3 - Network
  - The frames from layer 2 are assembled into IP packet
- Layer 4 - Transport
  - The IP packets from layer 3 are assembled into TCP segments
  - Deals with Congestion control/flow control/retransmission in case of TCP
  - If Segment is SYN we don't need to go further into more layers as we are still processing the connection request
- Layer 5 - Session
  - The connection session is established or identified
  - We only arrive at this layer when necessary (three-way handshake is done)
- Layer 6 - Presentation
  - Deserialize flat byte stings back to JSON for the app to consume
- Layer 7 - Application
  - Application understands the JSON POST request and your express json or apache request receive event is triggered 

## The shortcomings of the OSI Model
- OSI Model has too many layers which can be hard to comprehend
- Hard to argue about which layer does what
- Simpler to deal with Layers 5-6-7 as just one layer (Application layer) which the TCP/IP model does just that.

## TCP/IP Model
- Much simpler than OSI just 4 layers
- Application (Layer 5,6 and 7)
- Transport (Layer 4)
- Internet (Layer 3)
- Data Link (Layer 2)
- Physical layer if not officially part of the model

# Internet Protocol
## IP Packet
- The IP Packet has headers and data sections
- IP Packet header is 20 bytes (can go up to 60 bytes if options are enabled)
- Data section can go up to 65536

![image](https://github.com/boushphong/BE-Fundamentals/assets/59940078/c358976a-ee42-4eb3-91cb-3ca739201731)

When you send an HTTP request, the entire HTTP message, including the header, body, and any other associated data, is encapsulated within the data section of the TCP segment.

# ICMP
## What is ICMP?
ICMP is a protocol that operates at the network layer of the TCP/IP protocol stack. It is designed to facilitate communication between network devices and provide feedback about the health and status of network connections.
- Stands for Internet Control Message Protocol
- Designed for informational messages
  - Host unreachable, port unreachable, fragmentation needed
  - Packet expired (infinite loop in routers)
- Uses IP directly
- PING and traceroute use it
- Doesn't require listeners or ports to be opened

## Problems with ICMP
- Some firewalls block ICMP for security reasons, some routers between hops might drop IMCP.
- That is why PING might not work in those cases
- Disabling ICMP also can cause real damage with connection establishment
  - Fragmentation needed

# UDP
- Stands for User Datagram Protocol
- Layer 4 protocol
- Ability to address processes in a host using ports
- Simple protocol to send and receive data
- Prior communication not required (double edge sword)
- Stateless no knowledge is stored on the host
- 8 byte header Datagram

## UDP Use cases
**Ideal when you don't care about consistency all the time**
- Video Streaming
  - You don't care if some of the video data frames are dropped.
- VPN
  - Utilize UDP for reduced overhead and increased speed, prioritizing performance over TCP's reliability.
- DNS
  - DNS transactions, being lightweight and time-sensitive, opt for UDP due to its connectionless nature, allowing for faster query responses.
- WebRTC
  - WebRTC relies on UDP for low latency and real-time performance in applications like video conferencing, favoring responsiveness over guaranteed data delivery.
 
## UDP Datagram
- UDP Header is 8 bytes only (IPv4)
- Datagram slides into an IP packet as "data"
- Port are 16 bit (0 to 65535)

![image](https://github.com/boushphong/BE-Fundamentals/assets/59940078/97d000af-0543-427c-90f9-0228c5b30c03)

## UDP pros and cons
- Pros
  - Simple protocol
  - Header size is small so datagrams are small
  - Uses less bandwidth
  - Stateless
  - Consumes less memory (no state stored in the server/client)
  - Low latency - since there is no handshake, order, retransmission or gaaranteed delivery.
 
- Cons
  - No acknowledgement
  - No guarantee delivery
  - Connection-less - anyone can send data without prior knowledge
  - No flow control
  - No congestion control
  - No ordered packets
  - Security - can be easily spoofed

































